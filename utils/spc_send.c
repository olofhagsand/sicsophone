/*-----------------------------------------------------------------------------
  File:   spc_send.c
  Description: Sicsophone client application: sender side
  Author: Olof Hagsand
  CVS Version: $Id: spc_send.c,v 1.28 2005/02/16 14:02:36 olof Exp $
 
  This software is a part of SICSPHONE, a real-time, IP-based system for 
  point-to-point delivery of audio between computer end-systems.  

  Sicsophone is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  Sicsophone is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Sicsophone; see the file COPYING.

 *---------------------------------------------------------------------------*/

#ifdef HAVE_CONFIG_H
#include "config.h" /* generated by config & autoconf */
#endif

#include <fcntl.h>
#include <sys/stat.h>

#include "sphone.h"

#include "sp.h"
#include "spc.h"
#include "spc_send.h"

static FILE*
mymkstemp(char *filename, const char *mode)
{
    FILE *f;

#ifdef WIN32 /* XXX: could not find a good mkstmp function on win32 */
    char filepath[SPC_LOGFILE_LEN];
    char filename1[SPC_LOGFILE_LEN];
    char *s;
    struct timeval t;

    if (GetTempPath(SPC_LOGFILE_LEN, filepath) < 0){
      perror("mymkstemp: GetTempPath");
      return NULL;
    }
#if 0
    if (GetTempFileName(filepath, "spc", 0, filename1) < 0){
      perror("mymkstemp: GetTempFileName");
      return NULL;
    }
#endif
    if (s=strstr(filename, "XXXXXX")){
      t = gettimestamp();
      sprintf(s, "%06d", t.tv_usec);
    }
    dbg_print(DBG_APP, "Win32: Opening temporary file: %s\n", filename);
    if ((f = fopen(filename, mode)) == NULL){
      perror("mymkstemp: fopen");
      return NULL;
    }
#else /* WIN32 */
    int fd;

    if ((fd = mkstemp(filename)) < 0){
      perror("mymkstemp: mkstemp");
      return NULL;
    }
    if ((f = fdopen(fd, mode)) == NULL){
	fprintf(stderr, "%d %s\n", fd, mode);
  	perror("mymkstemp: fdopen");
        close(fd);
	return NULL;
    }
#endif /* WIN32 */
    return f;
}

/* return nr of packets to send */
static int
npackets(struct sp_send_session *ss)
{
    struct timeval t = gettimestamp();
    struct timeval tdiff;
    int passed_ms;

    /* How long time has passed (in s) ? */
    timersub(&t, &ss->ss_t0, &tdiff);

    if (tdiff.tv_sec < 0)
	return 0;

    /* 
     * How many packet intervals have passed? 
     * (how many packets should have been sent?) 
     */
    passed_ms = tdiff.tv_sec*1000+tdiff.tv_usec/1000;

    return passed_ms / ss->ss_coding.cp_size_ms;
} 

static int
send_data(int s, struct sp_send_session *ss, int pkts)
{
    static char buf[1500];
    static rtp_header hdr;            /* RTP header */
    int len = ss->ss_coding.cp_size_bytes + sizeof(rtp_header);

    memset(buf, 0, len);
    while (ss->ss_seq < pkts){
	rtp_set_hdr(&hdr, NULL, ss->ss_rtp_ssrc);  
	rtp_set_pt(hdr.flags, ss->ss_rtp_payload);
	hdr.seq = (ss->ss_seq++)%0x10000; 
	dbg_print(DBG_SEND, "send_data seq:%d\n", hdr.seq);
	marshal_rtp_hdr(&hdr, (char*)buf);
	dbg_print_pkt(DBG_SEND|DBG_DETAIL, "send_data", buf, len);
	if ((sendto(s, buf, len, 0x0, 
		    (struct sockaddr*)&ss->ss_dstaddr, 
		    sizeof(struct sockaddr_in))) < 0){
	    perror("send_data: sendto");
	    return -1;
	}
    }
    return 0;
}

static int
send_data_wrapper(int dummy, void *arg)
{
    struct sp_send_session *ss = (struct sp_send_session *)arg;
    struct spc_info *spc = ss->ss_spc;
    struct timeval tnow = gettimestamp();
    struct timeval dt;
    int pkts;

    if (spc->sp_state != SS_DATA_SEND && spc->sp_state != SS_DATA_SEND_CLOSING)
	return 0;
    if (spc->sp_state == SS_DATA_SEND_CLOSING){
	fclose(ss->ss_logf);
	ss->ss_logf = NULL;
	if (send_send_report(spc, &ss->ss_hdr, ss->ss_logfile) < 0)
	    return -1;
	unlink(ss->ss_logfile);
	ss->ss_logfile[0] = '\0';
	spc->sp_data = NULL;
	dbg_print(DBG_APP, "State: %s%d -> ", 
		  state2str(spc->sp_state), ss->ss_testid);
	sfree(ss);
	spc->sp_state = SS_SERVER;
	dbg_print(DBG_APP, "%s\n", state2str(spc->sp_state));
	return 0;
    }
    timersub(&tnow, &ss->ss_t0, &dt);
    /*
     * Stop sending if duration has passed
     * or if we don't receive any echoes.
     * Go to a closing state to receive any extra echoes.
     */
    if (timercmp(&ss->ss_duration, &dt, <) ||
	(ss->ss_rcvd == 0 && dt.tv_sec > SPC_SEND_TIMEOUT_S && 
	 ss->ss_seq > SPC_SEND_TIMEOUT_S*(1000/ss->ss_coding.cp_size_ms))){
      	dbg_print(DBG_APP, "State: %s -> ", state2str(spc->sp_state));
	spc->sp_state = SS_DATA_SEND_CLOSING;
	dbg_print(DBG_APP, "%s%d\n", 
		  state2str(spc->sp_state), ss->ss_testid);
	dt.tv_sec = 1;
	dt.tv_usec = 0;
	timeradd(&tnow, &dt, &dt);
	if (eventloop_reg_timeout(dt, send_data_wrapper, ss, 
			      "sicsophone data sender") < 0)
	  return -1;
	return 0;
    }
    pkts = npackets(ss); /* packets that should have been sent */
    if (pkts > 0)
	if (send_data(spc->sp_ds, ss, pkts) < 0)
	    return -1;
    tnow = gettimestamp();
    dt.tv_sec = ss->ss_coding.cp_size_ms/1000;
    dt.tv_usec = (ss->ss_coding.cp_size_ms%1000)*1000;
    timeradd(&tnow, &dt, &dt);
    if (eventloop_reg_timeout(dt, send_data_wrapper, ss, 
			      "sicsophone data sender") < 0){
	return -1;
    }
    return 0;
}

int
start_sender(struct spc_info *spc, struct sp_proto *sp)
{
    struct sp_send_session *ss;
    
    assert(spc->sp_state == SS_SERVER);
    if ((ss = (struct sp_send_session *)smalloc(sizeof(*ss))) == NULL){
	perror("start_sender: malloc");
	return -1;
    }
    memset(ss, 0, sizeof(*ss));
    spc->sp_data           = ss;
    ss->ss_testid          = ntohl(sp->sp_reporthdr.ss_testid);
    ss->ss_duration.tv_sec = ntohl(sp->sp_starthdr.ss_time_duration.tv_sec);
    ss->ss_duration.tv_usec = ntohl(sp->sp_starthdr.ss_time_duration.tv_usec);
    sp_addr_decode(&ss->ss_dstaddr, (char*)&sp->sp_starthdr.ss_addr_dst_pub);
    ss->ss_dstaddr.sin_port     = ss->ss_dstaddr.sin_port;
    ss->ss_spc            = spc;
    ss->ss_rtp_ssrc        = random_ssrc(0);
    ss->ss_rtp_payload     = RTP_PT_DYNAMIC;
    ss->ss_seq             = 0;
    ss->ss_coding          = spc->sp_coding;
    memcpy(&ss->ss_hdr, &sp->sp_starthdr, sizeof(struct sdhdr_start));
    ss->ss_t0              = gettimestamp();
    ss->ss_t0.tv_sec++;   /* wait a little before starting */
    /* Create logfile */
    strncpy(ss->ss_logfile, "spcXXXXXX", SPC_LOGFILE_LEN);
    if ((ss->ss_logf = mymkstemp(ss->ss_logfile, "w")) == NULL)
	return -1;
    dbg_print(DBG_SEND, "start_sender %d to: %s:%d duration: %d\n", 
	      ss->ss_testid,
	      inet_ntoa(ss->ss_dstaddr.sin_addr),
	      ntohs(ss->ss_dstaddr.sin_port),
	      ss->ss_duration.tv_sec);
    dbg_print(DBG_APP, "State: %s -> ", state2str(spc->sp_state));
    spc->sp_state = SS_DATA_SEND;
    dbg_print(DBG_APP, "%s%d\n", state2str(spc->sp_state), 
	      ss->ss_testid);
    if (send_data_wrapper(0, ss) < 0)
	return -1;
    return 0;
}

int
send_data_input(int s, struct spc_info *spc, struct sp_send_session *ss)
{
    static char buf[1500];
    char *p;
    static rtp_header hdr;            /* RTP header */
    struct sockaddr_in from;
    int len=sizeof(buf);
    struct timeval then, now, dT;
    int offset;

    memset(&from, 0, sizeof(struct sockaddr_in));
    assert(spc->sp_state == SS_DATA_SEND || 
	   spc->sp_state == SS_DATA_SEND_CLOSING);
    if (inet_input(s, buf, &len, &from) < 0)
	return 0;

    now = gettimestamp();
    p = buf;
    unmarshal_rtp_hdr(&hdr, buf);
    if (rtp_check_hdr(&hdr) < 0)
	return 0; /* Ignore */
    ss->ss_rcvd++;
    dbg_print(DBG_SEND, "send_data_input seq:%d\n", hdr.seq);
    NTP2TV(&hdr.ts, &then);
    timersub(&now, &then, &dT);
    offset = ss->ss_seq%0x10000 - hdr.seq; /* # outstanding packets */
    if (offset < 0)
	offset += 0x10000;
    fprintf(ss->ss_logf, "%d %ld.%06ld %ld.%06ld\n", 
	    ss->ss_seq - offset,  
	    dT.tv_sec, dT.tv_usec, 
	    then.tv_sec, then.tv_usec
	    );
#if 0
    if (rs->rs_ssrc != hdr.ssrc){
	fprintf(stderr, "Warning: unexpected sender src: %d\n", hdr.ssrc);
	return 0;
    }
#endif
    return 0;
}


/*
 * send_send_report
 * Send the results of the session to the server
 */
int
send_send_report(struct spc_info *spc, struct sdhdr_start *hdr_orig, char *logfile)
{
    struct sp_proto sp;
    int fd;
    int len;
    struct stat sb;
    char buf[SP_BUFLEN];
    int slen;
    int tlen = 0;

    if (stat(logfile, &sb) < 0){
	perror("send_send_report: stat");
	return -1;
    }
#ifdef WIN32
    fd = open(logfile, O_RDONLY|O_BINARY);
#else /* WIN32 */
    fd = open(logfile, O_RDONLY);
#endif /* WIN32 */
    if (fd < 0){
	perror("send_send_report: open");
	return -1;
    }
    /* Most of the header is same: copy and fill in differing fields */
    memset(&sp, 0, sizeof(sp));
    sp.sp_magic = SP_MAGIC;
    sp.sp_type  = SP_TYPE_REPORT_SEND;
    sp.sp_version = htons(SP_VERSION_NR);
    sp.sp_len   = htonl(sizeof(sp) + sb.st_size);
    sp.sp_id    = htonl(spc->sp_id);
    /* original session hdr */
    memcpy(&sp.sp_reporthdr, hdr_orig, sizeof(*hdr_orig));
    dbg_print_pkt(DBG_RCV|DBG_DETAIL, "send_send_report hdr", 
		  (void*)&sp, sizeof(sp));
    if ((slen = send(spc->sp_s, (void*)&sp, sizeof(sp), 0x0)) < 0){
	if (0){ /* XXX: socket to server breaks */
	    spc_state2init(spc);
	    return 0;
	}
	perror("send_send_report: send");
	return -1;
    }
    assert(slen == sizeof(sp));
    len = SP_BUFLEN;
    while (len > 0){
	if ((len = read(fd, buf, SP_BUFLEN)) < 0){
	    perror("send_send_report: read");
	    close(fd);
	    return -1;
	}
	dbg_print_pkt(DBG_RCV|DBG_DETAIL, "send_send_report file", buf, len);
	tlen += len;
#ifdef WIN32
    again: 
#endif
	if (len > 0)
	    if (send(spc->sp_s, buf, len, 0x0) < 0){
#ifdef WIN32
	      int errno = WSAGetLastError();
	      if (errno == WSAEWOULDBLOCK){
		fprintf(stderr, "send_send_report: send: wouldblock\n");
				Sleep(1);
		goto again;
	      }
#endif	      
		perror("send_send_report: send");
		close(fd);
		return -1;
	    }
    }
    close(fd);
    dbg_print(DBG_APP, "send_send_report: Sent %d bytes filesize: %d\n", 
	      tlen, sb.st_size);
    return 0;
}
